# 924. Minimize Malware Spread

planning before coding:

enumerate general cases: draw graph!

```python
def minMalwareSpread(graph, initial):        
    # input is given in adjacent matrix: converting to adjacent list takes O(n^2) time, n
    # brute force: simulation for each removal of the initial nodes: O(n^2 + kE), E = # of edges
    
    # one important note: undirected graph
    
    # 1. union-find: precompute connected components
    # 2. group initial nodes by component label
    # 3. find the nodes that is itself alone in a component, return the one with largest component in size
    #    if none found, return the first node
    n = len(graph)
    
    # 1. build Union-find (let's union!)
    id_ = list(range(n))
    sz = [1] * n
    
    def find(p):
        while p != id_[p]:
            id_[p] = id_[id_[p]]
            p = id_[p]
        return p
    
    def union(p, q):
        proot, qroot = find(p), find(q)
        if proot == qroot:
            return
        if sz[proot] >= sz[qroot]:
            id_[qroot] = proot
            sz[proot] += sz[qroot]
        else:
            id_[proot] = qroot
            sz[qroot] += sz[proot]
        
    for i in range(n):
        for j in range(i, n):
            if graph[i][j]:
                union(i, j)
    
    # 2. group intial nodes, actually just need count
    label2intials = {}  # int -> int[]
    for init in initial:
        label = find(init)
        label2intials.setdefault(label, []).append(init)
        
    # 3. find node alone node
    initial.sort()
    aloneNodes = [init for init in initial if len(label2intials[find(init)]) == 1]
    if not aloneNodes:
        return initial[0]  # should be the first intial node
    # print(id_, aloneNodes)
    result = aloneNodes[0]
    for node in aloneNodes:
        if sz[find(node)] > sz[find(result)]:
            result = node
    return result

# tests
# [[1,0,0],[0,1,1],[0,1,1]], [0,2] - expect 2
# [[1,0,0],[0,1,1],[0,1,1]], [0,1,2] - expect 0
```

