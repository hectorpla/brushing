# 489. Robot Room Cleaner

```text
def cleanRoom(self, robot):
    # idea: 
    # 1. maintain a log(stack) of instruction for the robot, for convenience to store the state, algo a little stupid
    # 2. maintain a map to keep track of external states {(int, int): int}
    # 2. backtracking
    
    dirs = [[-1,0], [0,-1], [1,0], [0,1]]
    dirState = 0
    log = []
    grid = {} # {(int, int): int}, 0: wall, 1: dirty, -1: clean
    
    def retreat(steps):
        robot.turnLeft()
        robot.turnLeft()
        for _ in range(steps):
            if log.pop() == 'l':
                robot.turnRight()
            else:
                robot.move()
        robot.turnLeft()
        robot.turnLeft()
            
    def clean(si, sj):
        nonlocal dirState
        robot.clean()
        grid[si,sj] = -1
        for _ in range(4):
            move(si, sj)
            robot.turnLeft()
            log.append('l')
            dirState = (dirState + 1) % 4
        
    def move(si, sj):
        di, dj = dirs[dirState]
        i, j = si + di, sj + dj
        if (i, j) in grid: # either wall or cleaned
            return
        if robot.move():
            step = len(log)
            log.append('m')
            clean(i, j)
            retreat(len(log) - step)
        else:
            grid[i,j] = 0
        
    clean(0, 0)
```

